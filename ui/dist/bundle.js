/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@heroiclabs/nakama-js/dist/nakama-js.umd.js":
/*!******************************************************************!*\
  !*** ./node_modules/@heroiclabs/nakama-js/dist/nakama-js.umd.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, (function (exports) { 'use strict';\n\n(function () {\n\n  var object =\n    typeof exports != 'undefined' ? exports :\n    typeof self != 'undefined' ? self : // #8: web workers\n    $.global; // #31: ExtendScript\n\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    var str = String(input);\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next str index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      str.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = str.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    var str = String(input).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=\n    if (str.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n\n(function(self) {\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue+','+value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push(name); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) { items.push(value); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push([name, value]); });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = 'status' in options ? options.status : 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : window);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\n\r\nvar __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar BASE_PATH = \"http://127.0.0.1:80\";\r\nvar NakamaApi = function (configuration) {\r\n    if (configuration === void 0) { configuration = {\r\n        basePath: BASE_PATH,\r\n        bearerToken: \"\",\r\n        password: \"\",\r\n        username: \"\",\r\n        timeoutMs: 5000,\r\n    }; }\r\n    return {\r\n        healthcheck: function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/healthcheck\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        getAccount: function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/account\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        updateAccount: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"PUT\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateCustom: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/custom\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateDevice: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/device\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateEmail: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/email\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateFacebook: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/facebook\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateGameCenter: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/gamecenter\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateGoogle: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/google\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        authenticateSteam: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/authenticate/steam\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkCustom: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/custom\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkDevice: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/device\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkEmail: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/email\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkFacebook: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/facebook\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkGameCenter: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/gamecenter\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkGoogle: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/google\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        linkSteam: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/link/steam\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkCustom: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/custom\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkDevice: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/device\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkEmail: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/email\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkFacebook: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/facebook\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkGameCenter: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/gamecenter\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkGoogle: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/google\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        unlinkSteam: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/account/unlink/steam\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listChannelMessages: function (channelId, limit, forward, cursor, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (channelId === null || channelId === undefined) {\r\n                throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/channel/{channel_id}\"\r\n                .replace(\"{channel_id}\", encodeURIComponent(String(channelId)));\r\n            var queryParams = {\r\n                limit: limit,\r\n                forward: forward,\r\n                cursor: cursor,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        deleteFriends: function (ids, usernames, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/friend\";\r\n            var queryParams = {\r\n                ids: ids,\r\n                usernames: usernames,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"DELETE\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listFriends: function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/friend\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        addFriends: function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/friend\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        blockFriends: function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/friend/block\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        importFacebookFriends: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/friend/facebook\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listGroups: function (name, cursor, limit, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/group\";\r\n            var queryParams = {\r\n                name: name,\r\n                cursor: cursor,\r\n                limit: limit,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        createGroup: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        deleteGroup: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"DELETE\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        updateGroup: function (groupId, body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"PUT\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        addGroupUsers: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}/add\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        joinGroup: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}/join\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        kickGroupUsers: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}/kick\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        leaveGroup: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}/leave\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        promoteGroupUsers: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}/promote\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listGroupUsers: function (groupId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (groupId === null || groupId === undefined) {\r\n                throw new Error(\"'groupId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/group/{group_id}/user\"\r\n                .replace(\"{group_id}\", encodeURIComponent(String(groupId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        deleteLeaderboardRecord: function (leaderboardId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (leaderboardId === null || leaderboardId === undefined) {\r\n                throw new Error(\"'leaderboardId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/leaderboard/{leaderboard_id}\"\r\n                .replace(\"{leaderboard_id}\", encodeURIComponent(String(leaderboardId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"DELETE\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listLeaderboardRecords: function (leaderboardId, ownerIds, limit, cursor, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (leaderboardId === null || leaderboardId === undefined) {\r\n                throw new Error(\"'leaderboardId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/leaderboard/{leaderboard_id}\"\r\n                .replace(\"{leaderboard_id}\", encodeURIComponent(String(leaderboardId)));\r\n            var queryParams = {\r\n                owner_ids: ownerIds,\r\n                limit: limit,\r\n                cursor: cursor,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        writeLeaderboardRecord: function (leaderboardId, body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (leaderboardId === null || leaderboardId === undefined) {\r\n                throw new Error(\"'leaderboardId' is a required parameter but is null or undefined.\");\r\n            }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/leaderboard/{leaderboard_id}\"\r\n                .replace(\"{leaderboard_id}\", encodeURIComponent(String(leaderboardId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listMatches: function (limit, authoritative, label, minSize, maxSize, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/match\";\r\n            var queryParams = {\r\n                limit: limit,\r\n                authoritative: authoritative,\r\n                label: label,\r\n                min_size: minSize,\r\n                max_size: maxSize,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        deleteNotifications: function (ids, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/notification\";\r\n            var queryParams = {\r\n                ids: ids,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"DELETE\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listNotifications: function (limit, cacheableCursor, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/notification\";\r\n            var queryParams = {\r\n                limit: limit,\r\n                cacheable_cursor: cacheableCursor,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        rpcFunc2: function (id, payload, httpKey, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (id === null || id === undefined) {\r\n                throw new Error(\"'id' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/rpc/{id}\"\r\n                .replace(\"{id}\", encodeURIComponent(String(id)));\r\n            var queryParams = {\r\n                payload: payload,\r\n                http_key: httpKey,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        rpcFunc: function (id, body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (id === null || id === undefined) {\r\n                throw new Error(\"'id' is a required parameter but is null or undefined.\");\r\n            }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/rpc/{id}\"\r\n                .replace(\"{id}\", encodeURIComponent(String(id)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        readStorageObjects: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/storage\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"POST\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        writeStorageObjects: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/storage\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"PUT\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        deleteStorageObjects: function (body, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (body === null || body === undefined) {\r\n                throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/storage/delete\";\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"PUT\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            fetchOptions.body = JSON.stringify(body || {});\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listStorageObjects: function (collection, userId, limit, cursor, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (collection === null || collection === undefined) {\r\n                throw new Error(\"'collection' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/storage/{collection}\"\r\n                .replace(\"{collection}\", encodeURIComponent(String(collection)));\r\n            var queryParams = {\r\n                user_id: userId,\r\n                limit: limit,\r\n                cursor: cursor,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listStorageObjects2: function (collection, userId, limit, cursor, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (collection === null || collection === undefined) {\r\n                throw new Error(\"'collection' is a required parameter but is null or undefined.\");\r\n            }\r\n            if (userId === null || userId === undefined) {\r\n                throw new Error(\"'userId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/storage/{collection}/{user_id}\"\r\n                .replace(\"{collection}\", encodeURIComponent(String(collection)))\r\n                .replace(\"{user_id}\", encodeURIComponent(String(userId)));\r\n            var queryParams = {\r\n                limit: limit,\r\n                cursor: cursor,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        getUsers: function (ids, usernames, facebookIds, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var urlPath = \"/v2/user\";\r\n            var queryParams = {\r\n                ids: ids,\r\n                usernames: usernames,\r\n                facebook_ids: facebookIds,\r\n            };\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n        listUserGroups: function (userId, options) {\r\n            if (options === void 0) { options = {}; }\r\n            if (userId === null || userId === undefined) {\r\n                throw new Error(\"'userId' is a required parameter but is null or undefined.\");\r\n            }\r\n            var urlPath = \"/v2/user/{user_id}/group\"\r\n                .replace(\"{user_id}\", encodeURIComponent(String(userId)));\r\n            var queryParams = {};\r\n            var urlQuery = \"?\" + Object.keys(queryParams)\r\n                .map(function (k) {\r\n                if (queryParams[k] instanceof Array) {\r\n                    return queryParams[k].reduce(function (prev, curr) {\r\n                        return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                    }, \"\");\r\n                }\r\n                else {\r\n                    if (queryParams[k] != null) {\r\n                        return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                    }\r\n                }\r\n            })\r\n                .join(\"\");\r\n            var fetchOptions = __assign({ method: \"GET\" }, options);\r\n            var headers = {\r\n                \"Accept\": \"application/json\",\r\n                \"Content-Type\": \"application/json\",\r\n            };\r\n            if (configuration.bearerToken) {\r\n                headers[\"Authorization\"] = \"Bearer \" + configuration.bearerToken;\r\n            }\r\n            else if (configuration.username) {\r\n                headers[\"Authorization\"] = \"Basic \" + btoa(configuration.username + \":\" + configuration.password);\r\n            }\r\n            fetchOptions.headers = __assign({}, headers, options.headers);\r\n            return Promise.race([\r\n                fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                    if (response.status >= 200 && response.status < 300) {\r\n                        return response.json();\r\n                    }\r\n                    else {\r\n                        throw response;\r\n                    }\r\n                }),\r\n                new Promise(function (_, reject) {\r\n                    return setTimeout(reject, configuration.timeoutMs, \"Request timed out.\");\r\n                }),\r\n            ]);\r\n        },\r\n    };\r\n};\n\nvar Session = (function () {\r\n    function Session(token, created_at, expires_at, username, user_id) {\r\n        this.token = token;\r\n        this.created_at = created_at;\r\n        this.expires_at = expires_at;\r\n        this.username = username;\r\n        this.user_id = user_id;\r\n    }\r\n    Session.prototype.isexpired = function (currenttime) {\r\n        return (this.expires_at - currenttime) < 0;\r\n    };\r\n    Session.restore = function (jwt) {\r\n        var createdAt = Math.floor(new Date().getTime() / 1000);\r\n        var parts = jwt.split('.');\r\n        if (parts.length != 3) {\r\n            throw 'jwt is not valid.';\r\n        }\r\n        var decoded = JSON.parse(atob(parts[1]));\r\n        var expiresAt = Math.floor(parseInt(decoded['exp']));\r\n        return new Session(jwt, createdAt, expiresAt, decoded['usn'], decoded['uid']);\r\n    };\r\n    return Session;\r\n}());\n\nvar DefaultSocket = (function () {\r\n    function DefaultSocket(host, port, useSSL, verbose) {\r\n        if (useSSL === void 0) { useSSL = false; }\r\n        if (verbose === void 0) { verbose = false; }\r\n        this.host = host;\r\n        this.port = port;\r\n        this.useSSL = useSSL;\r\n        this.verbose = verbose;\r\n        this.cIds = {};\r\n    }\r\n    DefaultSocket.prototype.generatecid = function () {\r\n        return __spread(Array(30)).map(function () { return Math.random().toString(36)[3]; }).join('');\r\n    };\r\n    DefaultSocket.prototype.connect = function (session, createStatus) {\r\n        var _this = this;\r\n        if (createStatus === void 0) { createStatus = false; }\r\n        if (this.socket != undefined) {\r\n            return Promise.resolve(session);\r\n        }\r\n        var scheme = (this.useSSL) ? \"wss://\" : \"ws://\";\r\n        var url = \"\" + scheme + this.host + \":\" + this.port + \"/ws?lang=en&status=\" + encodeURIComponent(createStatus.toString()) + \"&token=\" + encodeURIComponent(session.token);\r\n        var socket = new WebSocket(url);\r\n        this.socket = socket;\r\n        socket.onclose = function (evt) {\r\n            _this.ondisconnect(evt);\r\n            _this.socket = undefined;\r\n        };\r\n        socket.onerror = function (evt) {\r\n            _this.onerror(evt);\r\n        };\r\n        socket.onmessage = function (evt) {\r\n            var message = JSON.parse(evt.data);\r\n            if (_this.verbose && window && window.console) {\r\n                console.log(\"Response: %o\", message);\r\n            }\r\n            if (message.cid == undefined) {\r\n                if (message.notifications) {\r\n                    message.notifications.notifications.forEach(function (n) {\r\n                        var notification = {\r\n                            code: n.code,\r\n                            create_time: n.create_time,\r\n                            id: n.id,\r\n                            persistent: n.persistent,\r\n                            sender_id: n.sender_id,\r\n                            subject: n.subject,\r\n                            content: n.content ? JSON.parse(n.content) : undefined\r\n                        };\r\n                        _this.onnotification(notification);\r\n                    });\r\n                }\r\n                else if (message.match_data) {\r\n                    message.match_data.data = message.match_data.data != null ? JSON.parse(atob(message.match_data.data)) : null;\r\n                    message.match_data.op_code = parseInt(message.match_data.op_code);\r\n                    _this.onmatchdata(message.match_data);\r\n                }\r\n                else if (message.match_presence_event) {\r\n                    _this.onmatchpresence(message.match_presence_event);\r\n                }\r\n                else if (message.matchmaker_matched) {\r\n                    _this.onmatchmakermatched(message.matchmaker_matched);\r\n                }\r\n                else if (message.status_presence_event) {\r\n                    _this.onstatuspresence(message.status_presence_event);\r\n                }\r\n                else if (message.stream_presence_event) {\r\n                    _this.onstreampresence(message.stream_presence_event);\r\n                }\r\n                else if (message.stream_data) {\r\n                    _this.onstreamdata(message.stream_data);\r\n                }\r\n                else if (message.channel_message) {\r\n                    message.channel_message.content = JSON.parse(message.channel_message.content);\r\n                    _this.onchannelmessage(message.channel_message);\r\n                }\r\n                else if (message.channel_presence_event) {\r\n                    _this.onchannelpresence(message.channel_presence_event);\r\n                }\r\n                else {\r\n                    if (_this.verbose && window && window.console) {\r\n                        console.log(\"Unrecognized message received: %o\", message);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var executor = _this.cIds[message.cid];\r\n                if (!executor) {\r\n                    if (_this.verbose && window && window.console) {\r\n                        console.error(\"No promise executor for message: %o\", message);\r\n                    }\r\n                    return;\r\n                }\r\n                delete _this.cIds[message.cid];\r\n                if (message.error) {\r\n                    executor.reject(message.error);\r\n                }\r\n                else {\r\n                    executor.resolve(message);\r\n                }\r\n            }\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            socket.onopen = function (evt) {\r\n                if (_this.verbose && window && window.console) {\r\n                    console.log(evt);\r\n                }\r\n                resolve(session);\r\n            };\r\n            socket.onerror = function (evt) {\r\n                reject(evt);\r\n                socket.close();\r\n                _this.socket = undefined;\r\n            };\r\n        });\r\n    };\r\n    DefaultSocket.prototype.disconnect = function (fireDisconnectEvent) {\r\n        if (fireDisconnectEvent === void 0) { fireDisconnectEvent = true; }\r\n        if (this.socket != undefined) {\r\n            this.socket.close();\r\n        }\r\n        if (fireDisconnectEvent) {\r\n            this.ondisconnect({});\r\n        }\r\n    };\r\n    DefaultSocket.prototype.ondisconnect = function (evt) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(evt);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onerror = function (evt) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(evt);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onchannelmessage = function (channelMessage) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(channelMessage);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onchannelpresence = function (channelPresence) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(channelPresence);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onnotification = function (notification) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(notification);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onmatchdata = function (matchData) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(matchData);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onmatchpresence = function (matchPresence) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(matchPresence);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onmatchmakermatched = function (matchmakerMatched) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(matchmakerMatched);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onstatuspresence = function (statusPresence) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(statusPresence);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onstreampresence = function (streamPresence) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(streamPresence);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.onstreamdata = function (streamData) {\r\n        if (this.verbose && window && window.console) {\r\n            console.log(streamData);\r\n        }\r\n    };\r\n    DefaultSocket.prototype.send = function (message) {\r\n        var _this = this;\r\n        var m = message;\r\n        return new Promise(function (resolve, reject) {\r\n            if (_this.socket == undefined) {\r\n                reject(\"Socket connection has not been established yet.\");\r\n            }\r\n            else {\r\n                if (m.match_data_send) {\r\n                    m.match_data_send.data = btoa(JSON.stringify(m.match_data_send.data));\r\n                    m.match_data_send.op_code = m.match_data_send.op_code.toString();\r\n                    _this.socket.send(JSON.stringify(m));\r\n                    resolve();\r\n                }\r\n                else {\r\n                    if (m.channel_message_send) {\r\n                        m.channel_message_send.content = JSON.stringify(m.channel_message_send.content);\r\n                    }\r\n                    else if (m.channel_message_update) {\r\n                        m.channel_message_update.content = JSON.stringify(m.channel_message_update.content);\r\n                    }\r\n                    var cid = _this.generatecid();\r\n                    _this.cIds[cid] = {\r\n                        resolve: resolve,\r\n                        reject: reject\r\n                    };\r\n                    m.cid = cid;\r\n                    _this.socket.send(JSON.stringify(m));\r\n                }\r\n            }\r\n            if (_this.verbose && window && window.console) {\r\n                console.log(\"Sent message: %o\", m);\r\n            }\r\n        });\r\n    };\r\n    return DefaultSocket;\r\n}());\n\nvar DEFAULT_HOST = \"127.0.0.1\";\r\nvar DEFAULT_PORT = \"7350\";\r\nvar DEFAULT_SERVER_KEY = \"defaultkey\";\r\nvar DEFAULT_TIMEOUT_MS = 7000;\r\nvar Client = (function () {\r\n    function Client(serverkey, host, port, useSSL, timeout, verbose) {\r\n        if (serverkey === void 0) { serverkey = DEFAULT_SERVER_KEY; }\r\n        if (host === void 0) { host = DEFAULT_HOST; }\r\n        if (port === void 0) { port = DEFAULT_PORT; }\r\n        if (useSSL === void 0) { useSSL = false; }\r\n        if (timeout === void 0) { timeout = DEFAULT_TIMEOUT_MS; }\r\n        if (verbose === void 0) { verbose = false; }\r\n        this.serverkey = serverkey;\r\n        this.host = host;\r\n        this.port = port;\r\n        this.useSSL = useSSL;\r\n        this.timeout = timeout;\r\n        this.verbose = verbose;\r\n        var scheme = (useSSL) ? \"https://\" : \"http://\";\r\n        var basePath = \"\" + scheme + host + \":\" + port;\r\n        this.configuration = {\r\n            basePath: basePath,\r\n            username: serverkey,\r\n            password: \"\",\r\n            timeoutMs: timeout,\r\n        };\r\n        this.apiClient = NakamaApi(this.configuration);\r\n    }\r\n    Client.prototype.addGroupUsers = function (session, groupId, ids) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/group/\" + groupId + \"/add\";\r\n        var queryParams = {\r\n            user_ids: ids\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.addFriends = function (session, ids, usernames) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/friend\";\r\n        var queryParams = {\r\n            ids: ids,\r\n            usernames: usernames\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.authenticateCustom = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/custom\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            id: request.id\r\n        });\r\n        console.log;\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.authenticateDevice = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/device\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            id: request.id\r\n        });\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.authenticateEmail = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/email\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            email: request.email,\r\n            password: request.password\r\n        });\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.authenticateFacebook = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/facebook\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            token: request.token\r\n        });\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.authenticateGoogle = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/google\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            token: request.token\r\n        });\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.authenticateGameCenter = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/gamecenter\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            bundle_id: request.bundle_id,\r\n            player_id: request.player_id,\r\n            public_key_url: request.public_key_url,\r\n            salt: request.salt,\r\n            signature: request.signature,\r\n            timestamp_seconds: request.timestamp_seconds\r\n        });\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.authenticateSteam = function (request) {\r\n        var _this = this;\r\n        var urlPath = \"/v2/account/authenticate/steam\";\r\n        var queryParams = {\r\n            username: request.username,\r\n            create: request.create\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        fetchOptions.body = JSON.stringify({\r\n            token: request.token\r\n        });\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (apiSession) {\r\n            return Session.restore(apiSession.token || \"\");\r\n        });\r\n    };\r\n    Client.prototype.blockFriends = function (session, ids, usernames) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/friend/block\";\r\n        var queryParams = {\r\n            ids: ids,\r\n            usernames: usernames\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.createGroup = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.createGroup(request).then(function (response) {\r\n            return Promise.resolve({\r\n                avatar_url: response.avatar_url,\r\n                create_time: response.create_time,\r\n                creator_id: response.creator_id,\r\n                description: response.description,\r\n                edge_count: response.edge_count,\r\n                id: response.id,\r\n                lang_tag: response.lang_tag,\r\n                max_count: response.max_count,\r\n                metadata: response.metadata ? JSON.parse(response.metadata) : null,\r\n                name: response.name,\r\n                open: response.open,\r\n                update_time: response.update_time\r\n            });\r\n        });\r\n    };\r\n    Client.prototype.createSocket = function (useSSL, verbose) {\r\n        if (useSSL === void 0) { useSSL = false; }\r\n        if (verbose === void 0) { verbose = false; }\r\n        return new DefaultSocket(this.host, this.port, useSSL, verbose);\r\n    };\r\n    Client.prototype.deleteFriends = function (session, ids, usernames) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/friend\";\r\n        var queryParams = {\r\n            ids: ids,\r\n            usernames: usernames\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"DELETE\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.deleteGroup = function (session, groupId) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.deleteGroup(groupId).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.deleteNotifications = function (session, ids) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/notification\";\r\n        var queryParams = {\r\n            ids: ids\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"DELETE\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.deleteStorageObjects = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.deleteStorageObjects(request).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.getAccount = function (session) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.getAccount();\r\n    };\r\n    Client.prototype.importFacebookFriends = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.importFacebookFriends(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.getUsers = function (session, ids, usernames, facebookIds) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.getUsers(ids, usernames, facebookIds).then(function (response) {\r\n            var result = {\r\n                users: []\r\n            };\r\n            if (response.users == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.users.forEach(function (u) {\r\n                result.users.push({\r\n                    avatar_url: u.avatar_url,\r\n                    create_time: u.create_time,\r\n                    display_name: u.display_name,\r\n                    edge_count: u.edge_count,\r\n                    facebook_id: u.facebook_id,\r\n                    gamecenter_id: u.gamecenter_id,\r\n                    google_id: u.google_id,\r\n                    id: u.id,\r\n                    lang_tag: u.lang_tag,\r\n                    location: u.location,\r\n                    online: u.online,\r\n                    steam_id: u.steam_id,\r\n                    timezone: u.timezone,\r\n                    update_time: u.update_time,\r\n                    username: u.username,\r\n                    metadata: u.metadata ? JSON.parse(u.metadata) : null\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.joinGroup = function (session, groupId) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.joinGroup(groupId, {}).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.kickGroupUsers = function (session, groupId, ids) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/group/\" + groupId + \"/kick\";\r\n        var queryParams = {\r\n            user_ids: ids\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.leaveGroup = function (session, groupId) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.leaveGroup(groupId, {}).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.listChannelMessages = function (session, channelId, limit, forward, cursor) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listChannelMessages(channelId, limit, forward, cursor).then(function (response) {\r\n            var result = {\r\n                messages: [],\r\n                next_cursor: response.next_cursor,\r\n                prev_cursor: response.prev_cursor\r\n            };\r\n            if (response.messages == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.messages.forEach(function (m) {\r\n                result.messages.push({\r\n                    channel_id: m.channel_id,\r\n                    code: m.code,\r\n                    create_time: m.create_time,\r\n                    message_id: m.message_id,\r\n                    persistent: m.persistent,\r\n                    sender_id: m.sender_id,\r\n                    update_time: m.update_time,\r\n                    username: m.username,\r\n                    content: m.content ? JSON.parse(m.content) : null\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.listGroupUsers = function (session, groupId) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listGroupUsers(groupId).then(function (response) {\r\n            var result = {\r\n                group_users: []\r\n            };\r\n            if (response.group_users == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.group_users.forEach(function (gu) {\r\n                result.group_users.push({\r\n                    user: {\r\n                        avatar_url: gu.user.avatar_url,\r\n                        create_time: gu.user.create_time,\r\n                        display_name: gu.user.display_name,\r\n                        edge_count: gu.user.edge_count,\r\n                        facebook_id: gu.user.facebook_id,\r\n                        gamecenter_id: gu.user.gamecenter_id,\r\n                        google_id: gu.user.google_id,\r\n                        id: gu.user.id,\r\n                        lang_tag: gu.user.lang_tag,\r\n                        location: gu.user.location,\r\n                        online: gu.user.online,\r\n                        steam_id: gu.user.steam_id,\r\n                        timezone: gu.user.timezone,\r\n                        update_time: gu.user.update_time,\r\n                        username: gu.user.username,\r\n                        metadata: gu.user.metadata ? JSON.parse(gu.user.metadata) : null\r\n                    },\r\n                    state: gu.state\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.listUserGroups = function (session, userId) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listUserGroups(userId).then(function (response) {\r\n            var result = {\r\n                user_groups: []\r\n            };\r\n            if (response.user_groups == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.user_groups.forEach(function (ug) {\r\n                result.user_groups.push({\r\n                    group: {\r\n                        avatar_url: ug.group.avatar_url,\r\n                        create_time: ug.group.create_time,\r\n                        creator_id: ug.group.creator_id,\r\n                        description: ug.group.description,\r\n                        edge_count: ug.group.edge_count,\r\n                        id: ug.group.id,\r\n                        lang_tag: ug.group.lang_tag,\r\n                        max_count: ug.group.max_count,\r\n                        metadata: ug.group.metadata ? JSON.parse(ug.group.metadata) : null,\r\n                        name: ug.group.name,\r\n                        open: ug.group.open,\r\n                        update_time: ug.group.update_time\r\n                    },\r\n                    state: ug.state\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.listGroups = function (session, name, cursor, limit) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listGroups(name, cursor, limit).then(function (response) {\r\n            var result = {\r\n                groups: []\r\n            };\r\n            if (response.groups == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            result.cursor = response.cursor;\r\n            response.groups.forEach(function (ug) {\r\n                result.groups.push({\r\n                    avatar_url: ug.avatar_url,\r\n                    create_time: ug.create_time,\r\n                    creator_id: ug.creator_id,\r\n                    description: ug.description,\r\n                    edge_count: ug.edge_count,\r\n                    id: ug.id,\r\n                    lang_tag: ug.lang_tag,\r\n                    max_count: ug.max_count,\r\n                    metadata: ug.metadata ? JSON.parse(ug.metadata) : null,\r\n                    name: ug.name,\r\n                    open: ug.open,\r\n                    update_time: ug.update_time\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.linkCustom = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkCustom(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.linkDevice = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkDevice(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.linkEmail = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkEmail(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.linkFacebook = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkFacebook(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.linkGoogle = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkGoogle(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.linkGameCenter = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkGameCenter(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.linkSteam = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.linkSteam(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.listFriends = function (session) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listFriends().then(function (response) {\r\n            var result = {\r\n                friends: []\r\n            };\r\n            if (response.friends == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.friends.forEach(function (f) {\r\n                result.friends.push({\r\n                    user: {\r\n                        avatar_url: f.user.avatar_url,\r\n                        create_time: f.user.create_time,\r\n                        display_name: f.user.display_name,\r\n                        edge_count: f.user.edge_count,\r\n                        facebook_id: f.user.facebook_id,\r\n                        gamecenter_id: f.user.gamecenter_id,\r\n                        google_id: f.user.google_id,\r\n                        id: f.user.id,\r\n                        lang_tag: f.user.lang_tag,\r\n                        location: f.user.location,\r\n                        online: f.user.online,\r\n                        steam_id: f.user.steam_id,\r\n                        timezone: f.user.timezone,\r\n                        update_time: f.user.update_time,\r\n                        username: f.user.username,\r\n                        metadata: f.user.metadata ? JSON.parse(f.user.metadata) : null\r\n                    },\r\n                    state: f.state\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.listLeaderboardRecords = function (session, leaderboardId, ownerIds, limit, cursor) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listLeaderboardRecords(leaderboardId, ownerIds, limit, cursor).then(function (response) {\r\n            var list = {\r\n                next_cursor: response.next_cursor,\r\n                prev_cursor: response.prev_cursor,\r\n                owner_records: [],\r\n                records: []\r\n            };\r\n            if (response.owner_records != null) {\r\n                response.owner_records.forEach(function (o) {\r\n                    list.owner_records.push({\r\n                        expiry_time: o.expiry_time,\r\n                        leaderboard_id: o.leaderboard_id,\r\n                        metadata: o.metadata ? JSON.parse(o.metadata) : undefined,\r\n                        num_score: o.num_score,\r\n                        owner_id: o.owner_id,\r\n                        rank: Number(o.rank),\r\n                        score: Number(o.score),\r\n                        subscore: Number(o.subscore),\r\n                        update_time: o.update_time,\r\n                        username: o.username\r\n                    });\r\n                });\r\n            }\r\n            if (response.records != null) {\r\n                response.records.forEach(function (o) {\r\n                    list.records.push({\r\n                        expiry_time: o.expiry_time,\r\n                        leaderboard_id: o.leaderboard_id,\r\n                        metadata: o.metadata ? JSON.parse(o.metadata) : undefined,\r\n                        num_score: o.num_score,\r\n                        owner_id: o.owner_id,\r\n                        rank: Number(o.rank),\r\n                        score: Number(o.score),\r\n                        subscore: Number(o.subscore),\r\n                        update_time: o.update_time,\r\n                        username: o.username\r\n                    });\r\n                });\r\n            }\r\n            return Promise.resolve(list);\r\n        });\r\n    };\r\n    Client.prototype.listMatches = function (session, limit, authoritative, label, minSize, maxSize) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listMatches(limit, authoritative, label, minSize, maxSize);\r\n    };\r\n    Client.prototype.listNotifications = function (session, limit, cacheableCursor) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listNotifications(limit, cacheableCursor).then(function (response) {\r\n            var result = {\r\n                cacheable_cursor: response.cacheable_cursor,\r\n                notifications: [],\r\n            };\r\n            if (response.notifications == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.notifications.forEach(function (n) {\r\n                result.notifications.push({\r\n                    code: n.code,\r\n                    create_time: n.create_time,\r\n                    id: n.id,\r\n                    persistent: n.persistent,\r\n                    sender_id: n.sender_id,\r\n                    subject: n.subject,\r\n                    content: n.content ? JSON.parse(n.content) : undefined\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.listStorageObjects = function (session, collection, userId, limit, cursor) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.listStorageObjects(collection, userId, limit, cursor).then(function (response) {\r\n            var result = {\r\n                objects: [],\r\n                cursor: response.cursor\r\n            };\r\n            if (response.objects == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.objects.forEach(function (o) {\r\n                result.objects.push({\r\n                    collection: o.collection,\r\n                    key: o.key,\r\n                    permission_read: o.permission_read,\r\n                    permission_write: o.permission_write,\r\n                    value: o.value ? JSON.parse(o.value) : null,\r\n                    version: o.version,\r\n                    user_id: o.user_id,\r\n                    create_time: o.create_time,\r\n                    update_time: o.update_time\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.promoteGroupUsers = function (session, groupId, ids) {\r\n        var _this = this;\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var urlPath = \"/v2/group/\" + groupId + \"/promote\";\r\n        var queryParams = {\r\n            user_ids: ids\r\n        };\r\n        var urlQuery = \"?\" + Object.keys(queryParams)\r\n            .map(function (k) {\r\n            if (queryParams[k] instanceof Array) {\r\n                return queryParams[k].reduce(function (prev, curr) {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (queryParams[k] != null) {\r\n                    return encodeURIComponent(k) + \"=\" + encodeURIComponent(queryParams[k]) + \"&\";\r\n                }\r\n            }\r\n        })\r\n            .join(\"\");\r\n        var fetchOptions = __assign({ method: \"POST\" });\r\n        var headers = {\r\n            \"Accept\": \"application/json\",\r\n            \"Content-Type\": \"application/json\",\r\n        };\r\n        if (this.configuration.bearerToken) {\r\n            headers[\"Authorization\"] = \"Bearer \" + this.configuration.bearerToken;\r\n        }\r\n        else if (this.configuration.username) {\r\n            headers[\"Authorization\"] = \"Basic \" + btoa(this.configuration.username + \":\" + this.configuration.password);\r\n        }\r\n        fetchOptions.headers = __assign({}, headers);\r\n        return Promise.race([\r\n            fetch(this.configuration.basePath + urlPath + urlQuery, fetchOptions).then(function (response) {\r\n                if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise(function (_, reject) {\r\n                return setTimeout(reject, _this.configuration.timeoutMs, \"Request timed out.\");\r\n            }),\r\n        ]).then(function (response) {\r\n            return Promise.resolve(response != undefined);\r\n        });\r\n    };\r\n    Client.prototype.readStorageObjects = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.readStorageObjects(request).then(function (response) {\r\n            var result = { objects: [] };\r\n            if (response.objects == null) {\r\n                return Promise.resolve(result);\r\n            }\r\n            response.objects.forEach(function (o) {\r\n                result.objects.push({\r\n                    collection: o.collection,\r\n                    key: o.key,\r\n                    permission_read: o.permission_read,\r\n                    permission_write: o.permission_write,\r\n                    value: o.value ? JSON.parse(o.value) : null,\r\n                    version: o.version,\r\n                    user_id: o.user_id,\r\n                    create_time: o.create_time,\r\n                    update_time: o.update_time\r\n                });\r\n            });\r\n            return Promise.resolve(result);\r\n        });\r\n    };\r\n    Client.prototype.rpc = function (session, id, input) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.rpcFunc(id, JSON.stringify(input)).then(function (response) {\r\n            return Promise.resolve({\r\n                id: response.id,\r\n                payload: (!response.payload) ? null : JSON.parse(response.payload)\r\n            });\r\n        });\r\n    };\r\n    Client.prototype.rpcGet = function (id, session, httpKey, input) {\r\n        var _this = this;\r\n        if (!httpKey || httpKey == \"\") {\r\n            this.configuration.bearerToken = (session && session.token);\r\n        }\r\n        else {\r\n            this.configuration.username = undefined;\r\n            this.configuration.bearerToken = undefined;\r\n        }\r\n        return this.apiClient.rpcFunc2(id, input && JSON.stringify(input) || \"\", httpKey)\r\n            .then(function (response) {\r\n            _this.configuration.username = _this.serverkey;\r\n            return Promise.resolve({\r\n                id: response.id,\r\n                payload: (!response.payload) ? null : JSON.parse(response.payload)\r\n            });\r\n        }).catch(function (err) {\r\n            _this.configuration.username = _this.serverkey;\r\n            throw err;\r\n        });\r\n    };\r\n    Client.prototype.unlinkCustom = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkCustom(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.unlinkDevice = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkDevice(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.unlinkEmail = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkEmail(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.unlinkFacebook = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkFacebook(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.unlinkGoogle = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkGoogle(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.unlinkGameCenter = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkGameCenter(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.unlinkSteam = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.unlinkSteam(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.updateAccount = function (session, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.updateAccount(request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.updateGroup = function (session, groupId, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.updateGroup(groupId, request).then(function (response) {\r\n            return response !== undefined;\r\n        });\r\n    };\r\n    Client.prototype.writeLeaderboardRecord = function (session, leaderboardId, request) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        return this.apiClient.writeLeaderboardRecord(leaderboardId, {\r\n            metadata: request.metadata ? JSON.stringify(request.metadata) : undefined,\r\n            score: request.score,\r\n            subscore: request.subscore\r\n        }).then(function (response) {\r\n            return Promise.resolve({\r\n                expiry_time: response.expiry_time,\r\n                leaderboard_id: response.leaderboard_id,\r\n                metadata: response.metadata ? JSON.parse(response.metadata) : undefined,\r\n                num_score: response.num_score,\r\n                owner_id: response.owner_id,\r\n                score: Number(response.score),\r\n                subscore: Number(response.subscore),\r\n                update_time: response.update_time,\r\n                username: response.username\r\n            });\r\n        });\r\n    };\r\n    Client.prototype.writeStorageObjects = function (session, objects) {\r\n        this.configuration.bearerToken = (session && session.token);\r\n        var request = { objects: [] };\r\n        objects.forEach(function (o) {\r\n            request.objects.push({\r\n                collection: o.collection,\r\n                key: o.key,\r\n                permission_read: o.permission_read,\r\n                permission_write: o.permission_write,\r\n                value: JSON.stringify(o.value),\r\n                version: o.version\r\n            });\r\n        });\r\n        return this.apiClient.writeStorageObjects(request);\r\n    };\r\n    return Client;\r\n}());\n\nexports.Client = Client;\nexports.Session = Session;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/@heroiclabs/nakama-js/dist/nakama-js.umd.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _heroiclabs_nakama_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @heroiclabs/nakama-js */ \"./node_modules/@heroiclabs/nakama-js/dist/nakama-js.umd.js\");\n/* harmony import */ var _heroiclabs_nakama_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_heroiclabs_nakama_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar client = new _heroiclabs_nakama_js__WEBPACK_IMPORTED_MODULE_0___default.a.Client(\"defaultkey\", \"127.0.0.1\", 7350);\nclient.ssl = false;\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ })

/******/ });